<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>算法初探：一次算法在实际业务中的实践 | TimingZ</title><meta name="description" content="算法初探：一次算法在实际业务中的实践"><meta name="author" content="Timing"><meta name="copyright" content="Timing"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="算法初探：一次算法在实际业务中的实践"><meta name="twitter:description" content="算法初探：一次算法在实际业务中的实践"><meta name="twitter:image" content="http://121.40.114.220/wp-content/uploads/2016/10/lixianggup-.jpg"><meta property="og:type" content="article"><meta property="og:title" content="算法初探：一次算法在实际业务中的实践"><meta property="og:url" content="https://timingz.github.io/2020/05/29/hello-algorithm/"><meta property="og:site_name" content="TimingZ"><meta property="og:description" content="算法初探：一次算法在实际业务中的实践"><meta property="og:image" content="http://121.40.114.220/wp-content/uploads/2016/10/lixianggup-.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://timingz.github.io/2020/05/29/hello-algorithm/"><link rel="next" title="想点新的" href="https://timingz.github.io/2020/01/17/hello-world/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://timingz.github.io","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">TimingZ</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">2</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#算法初探：一次算法在实际业务中的实践"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">算法初探：一次算法在实际业务中的实践</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#需求内容"><span class="toc_mobile_items-number">1.1.</span> <span class="toc_mobile_items-text">需求内容</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#需求分析"><span class="toc_mobile_items-number">1.2.</span> <span class="toc_mobile_items-text">需求分析</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#思路"><span class="toc_mobile_items-number">1.3.</span> <span class="toc_mobile_items-text">思路</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#结果集"><span class="toc_mobile_items-number">1.3.1.</span> <span class="toc_mobile_items-text">结果集</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#订单与券的分组"><span class="toc_mobile_items-number">1.3.2.</span> <span class="toc_mobile_items-text">订单与券的分组</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#匹配问题"><span class="toc_mobile_items-number">1.3.3.</span> <span class="toc_mobile_items-text">匹配问题</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#尝试算法匹配"><span class="toc_mobile_items-number">1.3.4.</span> <span class="toc_mobile_items-text">尝试算法匹配</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#贪心算法"><span class="toc_mobile_items-number">1.3.4.1.</span> <span class="toc_mobile_items-text">贪心算法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#动态规划"><span class="toc_mobile_items-number">1.3.4.2.</span> <span class="toc_mobile_items-text">动态规划</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#动态规划的使用方式："><span class="toc_mobile_items-number">1.3.4.3.</span> <span class="toc_mobile_items-text">动态规划的使用方式：</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#背包算法"><span class="toc_mobile_items-number">1.3.4.3.1.</span> <span class="toc_mobile_items-text">背包算法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-6"><a class="toc_mobile_items-link" href="#01背包"><span class="toc_mobile_items-number">1.3.4.3.1.1.</span> <span class="toc_mobile_items-text">01背包</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-6"><a class="toc_mobile_items-link" href="#完全背包"><span class="toc_mobile_items-number">1.3.4.3.1.2.</span> <span class="toc_mobile_items-text">完全背包</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#优惠券满减"><span class="toc_mobile_items-number">1.3.4.3.2.</span> <span class="toc_mobile_items-text">优惠券满减</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#DFS"><span class="toc_mobile_items-number">1.3.4.4.</span> <span class="toc_mobile_items-text">DFS</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#剪枝优化："><span class="toc_mobile_items-number">1.3.4.5.</span> <span class="toc_mobile_items-text">剪枝优化：</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#二分搜索-binary-search"><span class="toc_mobile_items-number">1.3.4.6.</span> <span class="toc_mobile_items-text">二分搜索(binary search)</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#算法的选择"><span class="toc_mobile_items-number">1.4.</span> <span class="toc_mobile_items-text">算法的选择</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#算法的实现"><span class="toc_mobile_items-number">1.5.</span> <span class="toc_mobile_items-text">算法的实现</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#注意事项"><span class="toc_mobile_items-number">1.6.</span> <span class="toc_mobile_items-text">注意事项</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#后记"><span class="toc_mobile_items-number">1.7.</span> <span class="toc_mobile_items-text">后记</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Timing"><span class="toc_mobile_items-number">1.8.</span> <span class="toc_mobile_items-text">Timing-</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#算法初探：一次算法在实际业务中的实践"><span class="toc-number">1.</span> <span class="toc-text">算法初探：一次算法在实际业务中的实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#需求内容"><span class="toc-number">1.1.</span> <span class="toc-text">需求内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#需求分析"><span class="toc-number">1.2.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#思路"><span class="toc-number">1.3.</span> <span class="toc-text">思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#结果集"><span class="toc-number">1.3.1.</span> <span class="toc-text">结果集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#订单与券的分组"><span class="toc-number">1.3.2.</span> <span class="toc-text">订单与券的分组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配问题"><span class="toc-number">1.3.3.</span> <span class="toc-text">匹配问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尝试算法匹配"><span class="toc-number">1.3.4.</span> <span class="toc-text">尝试算法匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#贪心算法"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">贪心算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态规划"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态规划的使用方式："><span class="toc-number">1.3.4.3.</span> <span class="toc-text">动态规划的使用方式：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#背包算法"><span class="toc-number">1.3.4.3.1.</span> <span class="toc-text">背包算法</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#01背包"><span class="toc-number">1.3.4.3.1.1.</span> <span class="toc-text">01背包</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#完全背包"><span class="toc-number">1.3.4.3.1.2.</span> <span class="toc-text">完全背包</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#优惠券满减"><span class="toc-number">1.3.4.3.2.</span> <span class="toc-text">优惠券满减</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DFS"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">DFS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#剪枝优化："><span class="toc-number">1.3.4.5.</span> <span class="toc-text">剪枝优化：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二分搜索-binary-search"><span class="toc-number">1.3.4.6.</span> <span class="toc-text">二分搜索(binary search)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法的选择"><span class="toc-number">1.4.</span> <span class="toc-text">算法的选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算法的实现"><span class="toc-number">1.5.</span> <span class="toc-text">算法的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注意事项"><span class="toc-number">1.6.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#后记"><span class="toc-number">1.7.</span> <span class="toc-text">后记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Timing"><span class="toc-number">1.8.</span> <span class="toc-text">Timing-</span></a></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(http://121.40.114.220/wp-content/uploads/2016/10/lixianggup-.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">算法初探：一次算法在实际业务中的实践</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-05-29<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-06-04</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span><span class="post-meta__separator">|</span><i class="fa fa-comments-o post-meta__icon fa-fw" aria-hidden="true"></i><span>评论数:</span><a href="/2020/05/29/hello-algorithm/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/05/29/hello-algorithm/" itemprop="commentCount"></span></a></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="算法初探：一次算法在实际业务中的实践"><a href="#算法初探：一次算法在实际业务中的实践" class="headerlink" title="算法初探：一次算法在实际业务中的实践"></a>算法初探：一次算法在实际业务中的实践</h1><p><strong>一直以来对框架API更感兴趣，加上数学水平不高，对算法的学习很少。前几天收到了一个需求：“智能拆分订单”，</strong><br><strong>在实现的过程中，学习到了部分算法的知识。这里记录下过程以备忘，同时也分享下自己的理解。</strong></p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><hr>
<h2 id="需求内容"><a href="#需求内容" class="headerlink" title="需求内容"></a>需求内容</h2><ul>
<li><strong>如果订单可以匹配到对应的卡券，就按照卡券的金额进行拆分，比如一个订单的金额为500.00，如果可以匹配到五张100元的卡券，那么就把订单号关联到这五张卡券上，五张卡券就作为本次订单购买的商品详情。</strong><br><br></li>
<li><strong>不过实际情况下，A订单金额会是￥1892.88，B订单金额会是￥0.55，而C订单金额￥1.23这种，而且同一个名称的卡券，会有不同的金额与数量（也有可能没有），也就是说卡券的情况可能是： A卡券15元 x 5张，A卡券50元 x 1张，B卡券 120元 x 3张。</strong><br><br></li>
<li><strong>复杂情况下，如果卡券金额不足以完全抵消订单金额，那么就以事先维护好的对应的卡券的面额（面额都为正整数），去生成虚拟的卡券，最后无法匹配剩下的零钱的部分在单独标识作为一张虚拟卡去处理</strong><br><br></li>
<li><strong>重点在于如何让真实卡券集合与订单集合实现最优匹配</strong><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><blockquote>
<ul>
<li>按照订单名字与卡券名称一致作为匹配条件，将订单拆分成多个卡券，卡券金额为整数，例如50，100，200，订单金额保留到小数点后两位。</li>
<li>如果订单可以匹配到对应的卡券，就按照卡券的金额进行拆分，比如一个订单的金额为500.00，如果可以匹配到五张100元的卡券，那么就把订单号关联到这五张卡券上，五张卡券就作为本次订单购买的商品详情。</li>
<li>实际情况下，A订单金额会是￥1892.88，B订单金额会是￥0.55，而C订单金额￥1.23这种，而且同一个名称的卡券，会有不同的金额与数量（也有可能没有），也就是说卡券的情况可能是： A卡券15元 x 5张，A卡券50元 x 1张，B卡券 120元 x 3张。要求当卡券不足以抵消订单的全部金额时，以事先维护好的对应卡券的面额（同一个名字的卡券，面额也有很多种），去生成虚拟卡来“填充”这个金额。</li>
<li>简单解释一下就是，客户下一个商品名称为A的订单，我拿到这个A订单之后，把库存的n张不同金额的A券，以及m个不同A券的面额拿出来，以真实卡券为优先，虚拟面额为次级优先，去”尽可能“匹配订单的金额。匹配到真实卡券，就作为用户的商品，如果真实卡券金额不能满足订单金额（往往不能），就把剩余的金额按照面额去生成多张虚拟卡券，最后小于虚拟卡券面额的部分，就单独作为”零钱“再生成一张卡券。</li>
</ul>
</blockquote>
</li>
</ul>
<p>看完需求之后，我相信一个熟悉算法或者对业务灵敏度高的的可能马上就会想到：其实这就是一个最优选择优惠券满减场景。</p>
<p>关于金额匹配这里，在起初需求讨论的时候，我知道这里需要算法支持，不过并没有意识到这个场景其实算是“经典场景”。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="结果集"><a href="#结果集" class="headerlink" title="结果集"></a>结果集</h3><blockquote>
<ul>
<li>最后入库的数据场景多样化（整数真、整数假、零钱假），对于零钱，后面有其他的业务单独处理，而且零钱的值越小越好，三种数据最后增改操作是在一张表中。我设计将不同的场景数据分区再分区，然后分别处理。</li>
</ul>
</blockquote>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Boolean, Map&lt;Boolean, List&lt;Dto&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></div>
<blockquote>
<ul>
<li>外层布尔值区分整数（true）还是零钱（false），内层布尔值区分真（true）还是假（false），因为零钱都是假的，所以零钱的第二层只有（false）</li>
</ul>
</blockquote>
<h3 id="订单与券的分组"><a href="#订单与券的分组" class="headerlink" title="订单与券的分组"></a>订单与券的分组</h3><blockquote>
<ul>
<li>将订单按照名称分组取一，然后查出对应的券的集合，将订单以及券以名称分组并按照金额排序（正序）</li>
<li>在jdk8上借助stream很容易实现集合的各种操作，不是重点</li>
</ul>
</blockquote>
<h3 id="匹配问题"><a href="#匹配问题" class="headerlink" title="匹配问题"></a>匹配问题</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">现有 A券60元 x 2张，A券50元 x 2张， A券20元 x 1张  </span><br><span class="line">当收到A订单金额为130元时，最优匹配是使用 60元一张 、 50元一张、  20元一张，而不是匹配 60元两张， 余 10元。</span><br></pre></td></tr></table></figure></div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">130</th>
<th style="text-align:right">130</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">60</td>
<td style="text-align:right">60</td>
</tr>
<tr>
<td style="text-align:left">60</td>
<td style="text-align:right">50</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:right">20</td>
</tr>
</tbody>
</table>
</div>
<h3 id="尝试算法匹配"><a href="#尝试算法匹配" class="headerlink" title="尝试算法匹配"></a>尝试算法匹配</h3><blockquote>
<p>&emsp; 一开始，真的没有意识到这个是最优满减的场景，走了弯路，浪费了时间。实际上匹配的的需求，就是一笔订单中尽可能多的使用满减券，使得实际付款金额最小。<br>&emsp;本文以我个人理解来阐述，并不会引用官方描述，所以可能会出现表达不准确甚至很大偏差。如有发现请指正。</p>
</blockquote>
<h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><blockquote>
<p>&emsp;简单介绍： 在<strong>每一次</strong>选择中，都采用<strong>当前状态</strong>下的追求最优。</p>
<p>&emsp;初期讨论时, 有同事提出利用NavigableMap的方法(firstKey等)以最大金额去匹配，不过就会出现我上面例子的那种情况，会使用两个60元的而不是60、50、20。这种方式我理解为“贪心算法”，匹配目标是每次使用最少的券，而不是最优金额匹配。</p>
</blockquote>
<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><blockquote>
<p>&emsp;先说，最后我没有采用这种算法,不是因为算法的问题，一个是因为一开始使用的别的算法，还有就是，后期在实现中，发现业务中并不是完全的优惠券满减经典场景，后面会讲。</p>
<p>动态规划_dynamic programming_，我的理解就是<strong>如果可以</strong>通过找到一种数学上的客观规律，把大的问题分解成一个个小问题，再使用小问题之间的推算表达出来，<strong>这种推算的结果仅仅会因为规模而改变</strong>。 这个推算就可以作为大问题的通用解决办法。</p>
</blockquote>
<p>例如：一只兔子两只耳朵，两只兔子四只耳朵，三只兔子六只耳朵，那么求n只兔子多少只耳朵？</p>
<p>显而易见可以得出公式：</p>
<script type="math/tex; mode=display">f(n) = 2n</script><p>我们换一种写法：</p>
<script type="math/tex; mode=display">f(n) = f(n-1)+2</script><p>重新再屡一下上面对动态规划的理解。第二种公式的写法就是客观规律，兔子数量就是规模，规模增大，公式依然通用。</p>
<p>第一个公式很容易得出来，不过在复杂逻辑下，可能就很难得出，那么如果可以用第二种方式表达，就体现出动态规划的优点了。</p>
<h4 id="动态规划的使用方式："><a href="#动态规划的使用方式：" class="headerlink" title="动态规划的使用方式："></a>动态规划的使用方式：</h4><ol>
<li><strong>根据客观规律总结方程公式</strong><blockquote>
<p>上面的兔子耳朵数量公式其实很容易找到，但实际情况下复杂场景的规律往往不是那么容易找到，我没能正确的推导出公式，虽然在网上找到了其他人总结的公式，不过有些环节并没能完全理解其中的数学意义，并不想去背公式，所以也导致没有采用这个算法。这里再举一个清晰的例子来加深规律总结：</p>
</blockquote>
</li>
</ol>
<p>&emsp;&emsp;&emsp;斐波那契数列：0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233  当n&gt;2时<br><br></p>
<script type="math/tex; mode=display">f(n) = f(n-1)+f(n-2)</script><ol>
<li><strong>从小规模向大规模推导</strong><br>&emsp;这个比较容易理解，也符合一般的逻辑。<br><br></li>
<li><strong>缓存并复用计算结果</strong><br>&emsp;这个比较重要,可极大减少复杂度。算法本质是通过规律总结，如果计算了规模为10的结果，当再计算规模为11的结果时，就可以直接复用前面的结果，而不是再从头计算一遍。盗个图:<br><a href="https://terrenceho.org/img/fibtree5.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="缓存复用" class="fancybox"><img alt="缓存复用" title="缓存复用" data-src="https://terrenceho.org/img/fibtree5.png" class="lazyload"></a></li>
</ol>
<p>在斐波那契数列求值时，如果$fib(4)$和$fib(3)$在前面已经计算过，并把结果缓存，那么当需要计算$fib(5)$的时候，就可以直接计算出结果，而不需要从底层开始重新计算。</p>
<h5 id="背包算法"><a href="#背包算法" class="headerlink" title="背包算法"></a>背包算法</h5><p>&emsp;动态规划的一个经典场景————-背包算法</p>
<blockquote>
<p>背包算法: 就是给出一定数量的物品，物品的质量和价值（总价值）不等(质量更重的可能反而价格低)。一个承重有限的人，如何在<strong>满足一定条件下</strong>，让自己拿到的物品总价值最高的算法。<br>在背包算法中，这里举两个例子 _01背包_ &amp; _完全背包_<br>“01”和”完全”：就是上面说的一定条件下。这个命名我没有去考究是谁发明的，虽然没有让人望文生义，但也没能直观感受区别…<br><br><br><strong>01背包</strong>是每个物品的数量只有1个，每个物品也就最多能使用一次。<br><strong>完全背包</strong>是给定物品的数量是无限的，可以重复使用。</p>
<h6 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h6><p>设: 物品的质量与价格的关系表示为(质量，价格)<br><br><br>现有：(1,2)  (3,2) (2,1) (2,4) (3,5) 五个物品，每个物品只有一个，在给定承重条件下，一个人如何怎么拿物品可以使自己所拿的物品总价之和最高？</p>
</blockquote>
<p>上面提到过动态规划需要先找规律，这里我把规律以二维表的形式展示。<br><a href="https://i.loli.net/2020/05/25/vfT2BW7UukRHq4P.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="01背包.png" class="fancybox"><img alt="01背包.png" title="01背包.png" data-src="https://i.loli.net/2020/05/25/vfT2BW7UukRHq4P.png" class="lazyload"></a></p>
<p>第一行：没有物品，所以最大价值就是0，没什么好说的，同理第一列，承重是0，也无价值。<br>第二行：新增1号物品，质量1，价值2。当承重大于等于1且只有1号物品时，最大价值都是2<br>第三行：新增2号物品，质量3，价值2。当承重大于等于1，小于4（1号加二号的质量和），只能选择1一号物品，所以是2；<br>当承重大于等于4，可以同时拿起一号和二号，所以最大价值是4。<br>第四行：新增3号物品，质量2，价值1。我们从承重3开始看，当承重为3时，可以选择只拿一个二号，或者1、3号一起拿。显然拿1号和3号最大价值更大，为3。同理承重量为4、5时，会选择1、2号一起拿，最大价值为4。<br>以此类推……<br><br><br>其实通过表格的数据，已经看到结果是以一定规律呈现的，以某种顺序递增，注意这里物品的顺序是无序的，也就是说结果的这种递增规律<strong>没有受到物品顺序影响</strong>。注意这里加粗，后面的动态规划中，结果是会受到物品顺序影响的，后面会写。<br><br><br>上面提到的动态规划第二条使用方式，是从小规模到大规模推导，上面的表中承重量就是从小到大。<br><br><br>总结规律</p>
<blockquote>
<p>这里一开始就卡壳了，在网上看到其他人总结的结果，但是有一部分一开始没弄懂，然后因为不仅仅是要实现个算法，后面还有很多其他的逻辑着急往下进行，就没使用这个算法，写完需求之后又重新研究了一下。</p>
</blockquote>
<p>当 没有物品或者承重为0时，最大价值为0，第一行和第一列很明显。<br><br><br>当 承重量小于当前新增物品的质量时，取该承重量未添加新物品时的最大价值（就是当列的上一行，后面不再解释）。参考物品二所在行，承重2的列看，因为承重2没办法拿起质量3的2号物品，所以只能选择上一行质量1的1号物品。<br><br><br>当 承重量满足当前承重物品时有两种情况：</p>
<ul>
<li>1.当前物品虽然承重量大，但是价格低，所以取当列的上一行。参考物品3行承重2列的值，没有选则重量2价值1的3号物品，而是选择了质量1价值2的1号物品。</li>
<li>2.当前物品作为当前最大价值中的一部分，也就是选择了当前物品。参考右下角，选择了4号和5号物品。</li>
</ul>
<p>以数学公式表示一下，x为行，y为列，v为最大价值，v(x,y)表示x行y列的最大值，x(1)为该行对应物品的质量，x(2)为该物品的价值。有</p>
<script type="math/tex; mode=display">y=0 || x=0 时 v(x,y)=0</script><script type="math/tex; mode=display">x>0,y>0, y<x(1)时v(x,y)=v(x-1,y)</script><script type="math/tex; mode=display">
x>0,y>0,y>=x(1)时
v(x,y)=max\begin{cases}
v(x-1,y) \\\\
x(2)+v(x-1,y-x(1))\quad 
\end{cases}</script><p>前两个公式没什么可说的，最后一个是关键。最后一个公式是从两种可能的结果中取最大值</p>
<ul>
<li>1：先说第一个可能结果，参考第5列第三个物品行，最大值是上一行的结果，很简单。</li>
<li>2：第二个可能结果其实也很容易理解：第二个就是说最大值由当前物品的价值组成，参考右下角的数据，最大值就是由该行的物品价值组成。也就是说当没有这个物品时$(x-1)$，并且承重达不到这个物品的时候$(y-x(1))$，计算出的最大值$v(x-1,y-x(1))$,加上这个物品的质量$x(2)$，就是当承重达到这个物品质量，并且遇到这个物品时的最大价值。</li>
</ul>
<p>按照推导的逻辑附上一个简单实现的demo，<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">   dp(<span class="number">2</span>, Arrays.asList(</span><br><span class="line">           <span class="keyword">new</span> Goods(<span class="string">"1"</span>, <span class="number">1</span>, <span class="number">2</span>),</span><br><span class="line">           <span class="keyword">new</span> Goods(<span class="string">"2"</span>, <span class="number">3</span>, <span class="number">2</span>),</span><br><span class="line">           <span class="keyword">new</span> Goods(<span class="string">"3"</span>, <span class="number">2</span>, <span class="number">1</span>),</span><br><span class="line">           <span class="keyword">new</span> Goods(<span class="string">"4"</span>, <span class="number">2</span>, <span class="number">4</span>),</span><br><span class="line">           <span class="keyword">new</span> Goods(<span class="string">"5"</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">           )</span><br><span class="line">   );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> </span>&#123;</span><br><span class="line">     String id;</span><br><span class="line">     <span class="keyword">int</span> weight;</span><br><span class="line">     <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String id, <span class="keyword">int</span> weight, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.id = id;</span><br><span class="line">         <span class="keyword">this</span>.weight = weight;</span><br><span class="line">         <span class="keyword">this</span>.value = value;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * x为行对应物品号，y为列对应承重数量。</span></span><br><span class="line"><span class="comment">  * max[x][y]代表当承重达到y的时候，同时可以取到物品x时的最大价值。</span></span><br><span class="line"><span class="comment">  * 当指定承重n，与给定货物集合goods，求出此时可以拿起的最大价值，以及组成最大价值的货物。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> n, List&lt;Goods&gt; goods)</span> </span>&#123;</span><br><span class="line">  Integer[][] max = <span class="keyword">new</span> Integer[goods.size() + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">  Catcher[][] catchers = <span class="keyword">new</span> Catcher[goods.size() + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt;= n; y++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= goods.size(); x++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (y == <span class="number">0</span> || x == <span class="number">0</span>) &#123;</span><br><span class="line">          max[x][y] = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (y &lt; goods.get(x - <span class="number">1</span>).weight) &#123;</span><br><span class="line">          max[x][y] = max[x - <span class="number">1</span>][y];</span><br><span class="line">          catchers[x][y] = catchers[x - <span class="number">1</span>][y];</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (y &gt;= goods.get(x - <span class="number">1</span>).weight) &#123;</span><br><span class="line">      Integer maax = goods.get(x - <span class="number">1</span>).value + max[x - <span class="number">1</span>][y - goods.get(x - <span class="number">1</span>).weight];</span><br><span class="line">          <span class="keyword">if</span> (max[x - <span class="number">1</span>][y] &gt;= maax ) &#123;</span><br><span class="line">              max[x][y] = max[x - <span class="number">1</span>][y];</span><br><span class="line">              catchers[x][y] = catchers[x - <span class="number">1</span>][y];</span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">              max[x][y] = maax ;</span><br><span class="line">              catchers[x][y] = <span class="keyword">new</span> Catcher(goods.get(x-<span class="number">1</span>).id).add(</span><br><span class="line">              catchers[x-<span class="number">1</span>][y-goods.get(x-<span class="number">1</span>).weight]);</span><br><span class="line">          &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   System.out.println(max[goods.size()][n]);</span><br><span class="line">   System.out.println(catchers[goods.size()][n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Catcher</span> </span>&#123;</span><br><span class="line">   <span class="comment">//存储物品编号</span></span><br><span class="line">   List&lt;String&gt; goodsList;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Catcher</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.goodsList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">       goodsList.add(id);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Catcher <span class="title">add</span><span class="params">(Catcher catcher)</span></span>&#123;</span><br><span class="line">       Optional.ofNullable(catcher).</span><br><span class="line">               map(Catcher::copyContainer).</span><br><span class="line">               filter(l-&gt;!l.isEmpty())</span><br><span class="line">               .ifPresent(t-&gt;goodsList.addAll(t));</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">copyContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Optional.ofNullable(goodsList).orElseGet(LinkedList::<span class="keyword">new</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"Catcher&#123;"</span> +</span><br><span class="line">               <span class="string">"goodsList="</span> + goodsList +</span><br><span class="line">               <span class="string">'&#125;'</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输出结果</span><br><span class="line"><span class="number">7</span></span><br><span class="line">Catcher&#123;goodsList=[<span class="number">5</span>, <span class="number">1</span>]&#125;</span><br></pre></td></tr></table></figure></div><br><br></p>
<p>上面的结果是通过多次遍历得出的，不过实际上每次遍历中对最大值的计算都是以相同的方式。并且在关键的第三个公式中我们发现，两种可能的最大值都与上一行的值有关。也就是说我们得到一行的数据就可以得出下一行的最大值，所以这里可以二维变一维（去掉行，保留列）。</p>
<script type="math/tex; mode=display">
v(y)=max\begin{cases}
v(y) \\\\
x(2)+v(y-x(1))\quad 
\end{cases}</script><p>因为是一维数组，为了通过上一行数据推断下一行数据，我们的遍历顺序改成外层为物品，内层为承重。<br>于此同时，由于内层遍历的开始时，数组保留的是上一次遍历的上一行结果，在本次遍历中会依次修改成本行中对应列的值，这样会造成一个问题，如果从小到达遍历，会将上一行在数组内的对应数据以这一行的数据进行覆盖，这样会导致该行后面的数字无法由上一行的数据推算出，所以我们采用承重量的倒叙来遍历。<br>每次循环内的计算实际上就是用上一层的结果计算出这一层的结果。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**为减少篇幅，去掉了收集对应组合的代码*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dp1</span><span class="params">(<span class="keyword">int</span> n, List&lt;Goods&gt; goods)</span> </span>&#123;</span><br><span class="line">        Integer[] max = <span class="keyword">new</span> Integer[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt;= goods.size(); x++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = n; y &gt;= <span class="number">0</span>; y--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (y == <span class="number">0</span> || x == <span class="number">0</span>) &#123;</span><br><span class="line">                    max[y] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当承重小于物品重量时，保持上一行的数据</span></span><br><span class="line">                <span class="keyword">if</span> (y &gt;= goods.get(x - <span class="number">1</span>).weight) &#123;</span><br><span class="line">                    Integer maax = goods.get(x - <span class="number">1</span>).value + max[y - goods.get(x - <span class="number">1</span>).weight];</span><br><span class="line">                    <span class="keyword">if</span> (max[y] &gt;= maax) &#123;</span><br><span class="line">                        max[y] = max[y];</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        max[y] = maax;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(max[n]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></div></p>
<h6 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h6><blockquote>
<p>完全背包是指物品可以重复使用且数量不限。与我需要的场景不同，这里主要作为拓展。<br>完全背包的算法不止一种，这里选用将完全背包转化成01背包的方式计算。</p>
</blockquote>
<p>同样，对于动态规划，我们先找规律<br><a href="https://i.loli.net/2020/05/26/KhdmkpVYMeEnuFO.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="完全背包.png" class="fancybox"><img alt="完全背包.png" title="完全背包.png" data-src="https://i.loli.net/2020/05/26/KhdmkpVYMeEnuFO.png" class="lazyload"></a></p>
<p>通过图标中可以得出：在可重复选择的完全背包下，物品的性价比会决定该行结果。当遇到性价比极高的物品，该行的结果大致上按照该物品的价值呈线性增长；当遇到性价比低的物品，则几乎不会被选择。完全由之前行的结果取代。<br>所以总结出的二维公式为：</p>
<script type="math/tex; mode=display">
x>0,y>0,y>=x(1)时
v(x,y)=max\begin{cases}
v(x-1,y) \\\\
x(2)+v(x,y-x(1))\quad 
\end{cases}</script><p>01背包通过上一行数据推测该数据行，完全背包由于性价比问题，从本行推断本行数据。<br>同样，转化为一维数组</p>
<script type="math/tex; mode=display">
v(y)=max\begin{cases}
v(y) \\\\
x(2)+v(y-x(1))\quad 
\end{cases}</script><p>看上去和01背包的式子相同，不过我们在代码实现的时候，要把01背包中的的倒序改变成正序，其实原因上面已经解释过了，因为是一维数组，为了避免覆盖和值计算错误，不需要过分理解。如果上面的倒叙理解了，这里的正序也就能理解了，代码就不贴了。</p>
<h5 id="优惠券满减"><a href="#优惠券满减" class="headerlink" title="优惠券满减"></a>优惠券满减</h5><p>&emsp; 有限优惠券满减和01背包问题很相似，不过背包是以承重为限制，目标结果是一个最大值和；而满减券，在满足”满减”的前提下，要计算剩余金额最小值差，因为付款金额越小说明优惠券使用的越划算。<br>背包算法中，物品的顺序不影响结果。因为每一次计算结果不会限制下一次结果。限制下一次计算的是承重。<br>优惠券的算法中，券的顺序会影响结果。因为每一次计算记过会限制下一次结果（是否满足满减条件）。所以优惠券的问题上，为了实现最大满减，需要对券进行排序：</p>
<ul>
<li>同样满减条件的，按照减少金额倒序。</li>
<li>不同金额的，按照满减金额条件正序。</li>
</ul>
<p>盗了三张参考对比图，很容易理解。<br><a href="http://image.acfuu.com/mdImages/201906/coupon_bag/1560348525995.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="完全背包.png" class="fancybox"><img alt="完全背包.png" title="完全背包.png" data-src="http://image.acfuu.com/mdImages/201906/coupon_bag/1560348525995.png" class="lazyload"></a><br><a href="http://image.acfuu.com/mdImages/201906/coupon_bag/1560353330099.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="完全背包.png" class="fancybox"><img alt="完全背包.png" title="完全背包.png" data-src="http://image.acfuu.com/mdImages/201906/coupon_bag/1560353330099.png" class="lazyload"></a><br><a href="http://image.acfuu.com/mdImages/201906/coupon_bag/1560353494675.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="完全背包.png" class="fancybox"><img alt="完全背包.png" title="完全背包.png" data-src="http://image.acfuu.com/mdImages/201906/coupon_bag/1560353494675.png" class="lazyload"></a></p>
<p>为减少篇幅，代码实现请参考01背包。</p>
<p>优惠券满减的场景和需求场景一致，确实可以帮助我对目前业务中的需求场景进行最优匹配。</p>
<h4 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h4><blockquote>
<p>&emsp;DFS简单描述：从源节点下，尽可能深的搜索树的分支。 当一个节点下的所有路径都己被搜索过，搜索将回溯到该节点， 这一过程一直进行到已发现从源节点可达的所有节点为止。同一个节点在一条路径上不会出现两次。<br>这里盗用一张比较清晰的对比图来直观感受一下 左边是BFS，右边是DFS<br><a href="https://www.cwiki.us/download/attachments/41683903/binary_tree_search.png?version=1&amp;modificationDate=1545015592000&amp;api=v2" target="_blank" rel="noopener" data-fancybox="group" data-caption="DFS" class="fancybox"><img alt="DFS" title="DFS" data-src="https://www.cwiki.us/download/attachments/41683903/binary_tree_search.png?version=1&amp;modificationDate=1545015592000&amp;api=v2" class="lazyload"></a></p>
<p>BFS不做解释，也没有用到，只做对比，从命名上可以很好的理解算法追求的目标。<br>图示很明显DFS就是<strong>最大深度</strong>为搜索目标。</p>
</blockquote>
<p>回到我们的场景，使用dfs可以将真实卡的所有组合匹配出来，然后根据订单匹配出最合适的，也就是最终剩余金额最小的。<br>例如：</p>
<p>这听起来很暴力。<br>实际上在小规模可控数量上是可行的，并且利用业务特性”剪枝”剪掉一部分组合，减少了搜索数量，也提高了搜索效率。而且根据实际业务中发现，最大满减，其实并不是最优目标。</p>
<h4 id="剪枝优化："><a href="#剪枝优化：" class="headerlink" title="剪枝优化："></a>剪枝优化：</h4><blockquote>
<p>&emsp;属于算法优化的一种方式，不仅对DFS算法，在深度学习领域也起到很大的作用。根据业务逻辑对数据要先有一个认识和判断，需要准确高效的判断哪些路径是要去掉的。一个准确的剪枝会减少大量的搜索。<br>&emsp;当然剪枝本身在某些场景下也会有性能损耗，所以当一个剪枝判断本身要比多执行几次搜索还要费时，那么这个剪枝就并不高效。</p>
</blockquote>
<h4 id="二分搜索-binary-search"><a href="#二分搜索-binary-search" class="headerlink" title="二分搜索(binary search)"></a>二分搜索(binary search)</h4><blockquote>
<p>&emsp;二分搜索是使用的比较多的一种常见算法了。给定一个有序的由若干元素组成的区间，将区间取半，并不断的判断元素属于“左半边”还是”右半边”来定位元素最接近的值。当然也可能直接位于区间中间。</p>
</blockquote>
<h2 id="算法的选择"><a href="#算法的选择" class="headerlink" title="算法的选择"></a>算法的选择</h2><p> 先说结论：<strong>DFS(Deep First Search) 深度优先搜索算法&amp;剪枝&amp;二分搜索(binary search)</strong></p>
<h2 id="算法的实现"><a href="#算法的实现" class="headerlink" title="算法的实现"></a>算法的实现</h2><ul>
<li>通过迭代来实现对_Dfs_。</li>
<li>把券按照由大到小排列，由顶点开始向下寻找组合。这里有剪枝操作，当某个节点金额大于最大订单金额，或者某路径上的总和大于订单金额，则不再向下搜索。</li>
<li>把所有的组合以金额为key组合内真实卡的id集合为value存储（<strong>这里使用的IdentityHashMap</strong>）</li>
<li><strong>取组合的key按照金额倒序组成数组，遍历数组，数组内遍历订单，订单按照金额排序即可。</strong></li>
</ul>
<blockquote>
<p>算法的理解知识第一步，第二步是结合业务实现，第三步是优化。每一步都是重中之重。这里贴出部分代码以供参考。</p>
</blockquote>
<p>整个逻辑中，无论是深度搜索还是匹配我认为都相对容易理解。这里想分享下业务上的东西，也是上面加粗部分的原因，解释了目的，也有对场景的理解和优化以及不足, 这里把一些想法贴出来仅供参考。<br><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 最大匹配会出现一个情况： 前面订单金额是1000 用了900的组合，剩余了100，而后面刚好有一个订单金额是900，其实刚好可以匹配900的组合而没有剩余。</span></span><br><span class="line"><span class="comment">* 我们认为900的真卡匹配900的订单是最优。</span></span><br><span class="line"><span class="comment">* 如果不是最优，就需要额外的补偿，在使用过程中可能会遇到已经匹配的订单再次发生匹配，如果发生则说明是更优匹配，但是这样就会导致前面匹配的真卡被浪费。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 这里以外层循环是真卡组合的金额倒序数组，内层是订单金额排序集合（顺序倒序不强求）来解决。</span></span><br><span class="line"><span class="comment">* 外层是组合金额是为了让每一个组合的金额可以和订单充分接触，为了我们的最优而匹配。最优是以绝对值最小为原则，由于真卡组合金额必须小于订单金额，</span></span><br><span class="line"><span class="comment">* 所以真卡组合金额倒序可以确保前一个订单匹配到的订单，不会更适合下一个真卡组合金额。</span></span><br><span class="line"><span class="comment">* 比如1号组合金额是900 2号组合金额是500，内层遍历到了1500 和1000两个订单，900组合就会先和1000的订单匹配，900后面的组合都不会比900与1000差的绝对值最小。</span></span><br><span class="line"><span class="comment">* 所以通过这种方式就避免了发生“更优”。</span></span><br><span class="line"><span class="comment">* 不过当订单金额的最小值大于真卡组合的最大值时，会显得多此一举。不过实际业务中这种情况几乎不会发生。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 重复的问题，组合之间可能有重复的数据，一旦一个组合内的某一个元素被使用，则包含这个元素的组合全部作废。由大到小的排序下，</span></span><br><span class="line"><span class="comment">* 高多样化的组合（金额也更高），会让后面低多样化的组合直接作废。</span></span><br><span class="line"><span class="comment">* 因为还有一个目标，就是同一个元素在一个高多样化组合，一个低多样化组合中，如果可以使用高多样化组合匹配高金额订单，则优先。</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* 当真卡组合的区间整体小于订单金额区间，在完成最优匹配的部分后，会出现小卡匹配大单，允许，不过注意处理小于订单区间的卡都会匹配订单的倒数第二个</span></span><br><span class="line"><span class="comment">* 如果发生，就向左窜一格。不过这种方式在左侧连续被使用时，效率会不高。待优化</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure></div></p>
<p>迭代实现不难，贴合业务并优化也很重要。<br>避免不便，仅贴出一部分关于算法的代码以及部分数据结果的结构,仅供参考</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Dfs</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dfs</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 记录使用的节点，OrderPo为卡的泛型</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;OrderPO&gt; nodeBasket;</span><br><span class="line">   <span class="comment">//传入的待匹配集合</span></span><br><span class="line">   <span class="keyword">private</span> List&lt;OrderPO&gt; source;</span><br><span class="line">   <span class="comment">//订单最大值</span></span><br><span class="line">   <span class="keyword">private</span> BigDecimal maxAmt;</span><br><span class="line">   <span class="comment">//组合数,最大深度</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> no;</span><br><span class="line">   <span class="comment">//把一个map反复利用，按照最大深度，一个路径上对应深度都有一个值，当这个深度完成时，把整个路径拿出来</span></span><br><span class="line">   <span class="comment">//下次循环时，会重复赋值覆盖掉前面的，因为最大深度是相同的，所以可以完全覆盖</span></span><br><span class="line">   <span class="keyword">private</span> Map&lt;Integer, OrderPO&gt; line;</span><br><span class="line">   <span class="comment">//按照最大深度完成的组合，并返回</span></span><br><span class="line">   <span class="keyword">private</span> Map&lt;BigDecimal, List&lt;OrderPO&gt;&gt; co;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Dfs</span><span class="params">(List&lt;OrderPO&gt; source, BigDecimal maxAmt,<span class="keyword">int</span> no)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.source = source;</span><br><span class="line">       <span class="keyword">this</span>.nodeBasket = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">       <span class="keyword">this</span>.maxAmt = maxAmt;</span><br><span class="line">       <span class="keyword">this</span>.no = no;</span><br><span class="line">       <span class="keyword">this</span>.line = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       <span class="keyword">this</span>.co = <span class="keyword">new</span> IdentityHashMap&lt;&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Map&lt;BigDecimal, List&lt;OrderPO&gt;&gt; complete() &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.co;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//受外部控制，组合数量</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">def</span><span class="params">(BigDecimal amt, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">null</span> == source) &#123;</span><br><span class="line">           <span class="comment">//不迭代</span></span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (no == n) &#123;</span><br><span class="line">           <span class="comment">//迭代完成，将这一次的迭代路径放进去。</span></span><br><span class="line">           co.put(amt, getline());</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; source.size(); i++) &#123;</span><br><span class="line">               <span class="comment">//已被使用</span></span><br><span class="line">               <span class="keyword">if</span> (nodeBasket.contains(source.get(i))) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//如果单个金额太大则抛弃该节点</span></span><br><span class="line">               BigDecimal thisPric = source.get(i).getPrdPrice();</span><br><span class="line">               <span class="keyword">if</span> (DecimalUtil.gt(thisPric, maxAmt)) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//保证路径方向的一致性</span></span><br><span class="line">               <span class="keyword">if</span> (n&gt;=<span class="number">1</span> &amp;&amp; DecimalUtil.gt(thisPric, line.get(n-<span class="number">1</span>).getPrdPrice())) &#123;</span><br><span class="line">                   <span class="keyword">continue</span>;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//计算出一条路径上的金额</span></span><br><span class="line">               BigDecimal newAmt = DecimalUtil.add(amt, source.get(i).getPrdPrice());</span><br><span class="line">               <span class="comment">//如果路径上的金额大于最大值了其实就没意义了，也抛弃</span></span><br><span class="line">               <span class="keyword">if</span> (DecimalUtil.ge(newAmt, maxAmt)) &#123;</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//加入节点</span></span><br><span class="line">               nodeBasket.add(source.get(i));</span><br><span class="line">               <span class="comment">//加入结果,每种结果都是一种组合，一个或多个，</span></span><br><span class="line">               line.put(n, source.get(i));</span><br><span class="line">               <span class="comment">//递归搜索节点路径</span></span><br><span class="line">               def(newAmt, n + <span class="number">1</span>);</span><br><span class="line">               <span class="comment">//移出节点</span></span><br><span class="line">               nodeBasket.remove(source.get(i));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> List&lt;OrderPO&gt; <span class="title">getline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> line.entrySet().stream().map(Map.Entry::getValue).collect(Collectors.toList());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**二分法匹配，部分代码*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; amtArray.size(); i++) &#123;</span><br><span class="line">     BigDecimal amt = amtArray.get(i);</span><br><span class="line">     <span class="comment">/**二分法，匹配最优订单，真卡组合的金额不可以大于订单金额，以二者差的绝对值最小为最优。</span></span><br><span class="line"><span class="comment">      * */</span></span><br><span class="line">     Set&lt;String&gt; coList = combine.get(amt).stream().map(OrderPO::getPrdSeq).collect(Collectors.toSet());</span><br><span class="line">     <span class="keyword">if</span> (usedIdSet.containsAll(coList)) &#123;</span><br><span class="line">         <span class="keyword">continue</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//全部订单完成匹配则终止继续匹配</span></span><br><span class="line">     <span class="keyword">if</span> (arr.size()==undel.size()) &#123;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right=undel.size()-<span class="number">1</span>; left &lt;= right;) &#123;</span><br><span class="line">         <span class="comment">//如果这个订单已经被使用过了，就执行下一次循环</span></span><br><span class="line">         <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">         OrderPO pO = undel.get(mid);</span><br><span class="line"></span><br><span class="line">         <span class="comment">//bingo</span></span><br><span class="line">         <span class="keyword">if</span> (DecimalUtil.eq(pO.getOrderAmt(),amt))&#123;</span><br><span class="line">             <span class="comment">//如果mid对应的订单有没有被匹配</span></span><br><span class="line">             <span class="keyword">if</span> (!arr.contains(Integer.valueOf(mid))) &#123;</span><br><span class="line">                 <span class="comment">//记录该订单已经被匹配</span></span><br><span class="line">                 arr.add(mid);</span><br><span class="line"></span><br><span class="line">                 <span class="comment">//使用了真卡</span></span><br><span class="line">                 map.put(pO.getOrderSeq(), amt);</span><br><span class="line">                 usedIdSet.addAll(coList);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//如果这个订单已经被匹配了，就去找比这个订单金额大的区间，在区间左侧</span></span><br><span class="line">                 right = mid-<span class="number">1</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (DecimalUtil.gt(amt,pO.getOrderAmt())) &#123;</span><br><span class="line">             <span class="comment">//如果在左侧区间</span></span><br><span class="line">             right = mid;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(DecimalUtil.lt(amt,pO.getOrderAmt())) &#123;</span><br><span class="line">             <span class="comment">//如果在右侧区间</span></span><br><span class="line">             left = mid;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">//不在这个区间内</span></span><br><span class="line">         <span class="keyword">if</span> (right-left&lt;=<span class="number">1</span>) &#123;</span><br><span class="line">             <span class="comment">//如果没有被使用过取左侧，订单金额一定要大于组合金额</span></span><br><span class="line">             <span class="keyword">if</span> (!arr.contains(Integer.valueOf(left))) &#123;</span><br><span class="line">                 <span class="comment">//记录该订单已经被匹配</span></span><br><span class="line">                 arr.add(left);</span><br><span class="line">                 <span class="comment">//如果元素没有被使用</span></span><br><span class="line">                 <span class="comment">//使用了真卡</span></span><br><span class="line">                 map.put(undel.get(left).getOrderSeq(), amt);</span><br><span class="line">                 usedIdSet.addAll(coList);</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">             &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//可能被使用了，这里不是一个高效的方式，未来需要优化 TODO</span></span><br><span class="line">                 <span class="keyword">if</span>(left&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                     left -= <span class="number">1</span>;</span><br><span class="line">                     right -= <span class="number">1</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> map;</span><br></pre></td></tr></table></figure></div>
<p>有三张真卡，金额为20、40、30。<br>外层List的index+1代表最大深度，index为0时，最大深度0+1=1，所以对应三种组合。<br>index为1时，最大深度1+1=2，通过两两组合，所以有三种组合方式的金额以及对应的组合内容…<br><a href="https://i.loli.net/2020/05/28/PqLgwGxXiESRmVU.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="组金额关系.png" class="fancybox"><img alt="组金额关系.png" title="组金额关系.png" data-src="https://i.loli.net/2020/05/28/PqLgwGxXiESRmVU.png" class="lazyload"></a></p>
<p>将组合合并，不以最大深度区分<br><a href="https://i.loli.net/2020/05/28/uQtnb54Tj9WN1L7.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="组合与金额关系3.png" class="fancybox"><img alt="组合与金额关系3.png" title="组合与金额关系3.png" data-src="https://i.loli.net/2020/05/28/uQtnb54Tj9WN1L7.png" class="lazyload"></a></p>
<p>将所有组合的金额(key)拿出来排序进行二分搜索<br><a href="https://i.loli.net/2020/05/28/qAFWCyZ6Gma8UVQ.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="组合与金额关系2.png" class="fancybox"><img alt="组合与金额关系2.png" title="组合与金额关系2.png" data-src="https://i.loli.net/2020/05/28/qAFWCyZ6Gma8UVQ.png" class="lazyload"></a></p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><blockquote>
<p>我们都知道运行线程会在jvm（以hotspot为例）中的虚拟机栈上开辟线程私有的一块空间，线程整个生命周期中的每一个方法，都会作为该线程调用栈上的栈帧，当搜索深度足够深，迭代发生次数足够多，那么栈帧的数量也会明显提升。那么就可能会引起栈内存溢出_StackOverflowError_.</p>
</blockquote>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><ul>
<li>主要是记录一下思路和对算法的理解，代码层面的实现在不同语言和业务中会不同，整个业务流程实现中也有很多其他的重点，这里只说明算法部分。</li>
<li>解决类似问题的方法一定不是唯一的，了解数学意义对理解算法有一定帮助。</li>
<li>这里没有对比时间复杂度和空间复杂度，对比两种优劣，后面如果有时间，再补充。</li>
<li>回过头看，匹配这里其实如果思路清晰，并没有很难，实现与优化上又是一门功夫。</li>
<li>水平有限，我的实现也一定有改进的地方，并不是最优或者通用的。</li>
<li>如果你发现问题或者优化建议可以交流。</li>
</ul>
<h2 id="Timing"><a href="#Timing" class="headerlink" title="Timing-"></a>Timing-</h2><p>Don’t say it,unless YOU mean it.</p>
<hr>
</div></article><div class="tag_share"><div class="post_share"><div class="social-share" data-image="http://121.40.114.220/wp-content/uploads/2016/10/lixianggup-.jpg" data-sites="wechat"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/01/17/hello-world/"><img class="next_cover lazyload" data-src="http://121.40.114.220/wp-content/uploads/2016/10/lixianggup-.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>想点新的</span></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'xRRKig4W544BnhYtjcmqGUrK-gzGzoHsz',
  appKey:'xa7UxGtaGtPXNEHank3ALSzx',
  placeholder:'.......',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></main><footer id="footer" style="background-image: url(http://121.40.114.220/wp-content/uploads/2016/10/lixianggup-.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Timing</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/canvas-nest.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end --></body></html>